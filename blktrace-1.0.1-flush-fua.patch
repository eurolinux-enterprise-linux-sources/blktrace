From: Namhyung Kim <namhyung@gmail.com>
Date: Thu, 11 Aug 2011 10:48:07 +0000 (+0200)
Subject: Add FLUSH/FUA support
X-Git-Tag: blktrace-1.0.3~1
X-Git-Url: http://git.kernel.dk/?p=blktrace.git;a=commitdiff_plain;h=344320932064efa7105314d2437027b0733f4631

Add FLUSH/FUA support

Add FLUSH/FUA support to blktrace. As FLUSH precedes WRITE and/or
FUA follows WRITE, use the same 'F' flag for both cases and
distinguish them by their (relative) position. The end results
look like (other flags might be shown also):

 - WRITE:            W
 - WRITE_FLUSH:      FW
 - WRITE_FUA:        WF
 - WRITE_FLUSH_FUA:  FWF

Note that we reuse TC_BARRIER due to lack of bit space of act_mask.

Signed-off-by: Namhyung Kim <namhyung@gmail.com>
Signed-off-by: Jens Axboe <jaxboe@fusionio.com>
---

Index: blktrace-1.0.1/act_mask.c
===================================================================
--- blktrace-1.0.1.orig/act_mask.c
+++ blktrace-1.0.1/act_mask.c
@@ -15,7 +15,7 @@ struct mask_map {
 static struct mask_map mask_maps[] = {
 	DECLARE_MASK_MAP(READ),
 	DECLARE_MASK_MAP(WRITE),
-	DECLARE_MASK_MAP(BARRIER),
+	DECLARE_MASK_MAP(FLUSH),
 	DECLARE_MASK_MAP(SYNC),
 	DECLARE_MASK_MAP(QUEUE),
 	DECLARE_MASK_MAP(REQUEUE),
@@ -28,6 +28,7 @@ static struct mask_map mask_maps[] = {
 	DECLARE_MASK_MAP(META),
 	DECLARE_MASK_MAP(DISCARD),
 	DECLARE_MASK_MAP(DRV_DATA),
+	DECLARE_MASK_MAP(FUA),
 };
 
 int find_mask_map(char *string)
Index: blktrace-1.0.1/blkparse_fmt.c
===================================================================
--- blktrace-1.0.1.orig/blkparse_fmt.c
+++ blktrace-1.0.1/blkparse_fmt.c
@@ -54,12 +54,16 @@ static inline void fill_rwbs(char *rwbs,
 {
 	int w = t->action & BLK_TC_ACT(BLK_TC_WRITE);
 	int a = t->action & BLK_TC_ACT(BLK_TC_AHEAD);
-	int b = t->action & BLK_TC_ACT(BLK_TC_BARRIER);
 	int s = t->action & BLK_TC_ACT(BLK_TC_SYNC);
 	int m = t->action & BLK_TC_ACT(BLK_TC_META);
 	int d = t->action & BLK_TC_ACT(BLK_TC_DISCARD);
+	int f = t->action & BLK_TC_ACT(BLK_TC_FLUSH);
+	int u = t->action & BLK_TC_ACT(BLK_TC_FUA);
 	int i = 0;
 
+	if (f)
+		rwbs[i++] = 'F'; /* flush */
+
 	if (d)
 		rwbs[i++] = 'D';
 	else if (w)
@@ -68,10 +72,11 @@ static inline void fill_rwbs(char *rwbs,
 		rwbs[i++] = 'R';
 	else
 		rwbs[i++] = 'N';
+
+	if (u)
+		rwbs[i++] = 'F'; /* fua */
 	if (a)
 		rwbs[i++] = 'A';
-	if (b)
-		rwbs[i++] = 'B';
 	if (s)
 		rwbs[i++] = 'S';
 	if (m)
@@ -188,7 +193,7 @@ static void print_field(char *act, struc
 		break;
 	}
 	case 'd': {
-		char rwbs[6];
+		char rwbs[8];
 
 		fill_rwbs(rwbs, t);
 		fprintf(ofp, strcat(format, "s"), rwbs);
@@ -285,7 +290,7 @@ static void process_default(char *act, s
 			    int pdu_len, unsigned char *pdu_buf)
 {
 	struct blk_io_trace_remap r = { .device_from = 0, };
-	char rwbs[6];
+	char rwbs[8];
 	char *name;
 
 	fill_rwbs(rwbs, t);
@@ -445,7 +450,7 @@ void process_fmt(char *act, struct per_c
 			case 'r': fprintf(ofp, "\r"); break;
 			case 't': fprintf(ofp, "\t"); break;
 			default:
-				fprintf(stderr,	
+				fprintf(stderr,
 					"Invalid escape char in format %c\n",
 					p[1]);
 				exit(1);
Index: blktrace-1.0.1/blkrawverify.c
===================================================================
--- blktrace-1.0.1.orig/blkrawverify.c
+++ blktrace-1.0.1/blkrawverify.c
@@ -39,7 +39,7 @@ int data_is_native = -1;
 static struct trace_info traces[] = {
 	TRACE_TO_STRING( BLK_TC_READ ),
 	TRACE_TO_STRING( BLK_TC_WRITE ),
-	TRACE_TO_STRING( BLK_TC_BARRIER ),
+	TRACE_TO_STRING( BLK_TC_FLUSH ),
 	TRACE_TO_STRING( BLK_TC_SYNC ),
 	TRACE_TO_STRING( BLK_TC_QUEUE ),
 	TRACE_TO_STRING( BLK_TC_REQUEUE ),
@@ -50,6 +50,7 @@ static struct trace_info traces[] = {
 	TRACE_TO_STRING( BLK_TC_AHEAD ),
 	TRACE_TO_STRING( BLK_TC_META ),
 	TRACE_TO_STRING( BLK_TC_DISCARD ),
+	TRACE_TO_STRING( BLK_TC_FUA ),
 };
 #define N_TRACES (sizeof(traces) / sizeof(struct trace_info))
 
Index: blktrace-1.0.1/blktrace_api.h
===================================================================
--- blktrace-1.0.1.orig/blktrace_api.h
+++ blktrace-1.0.1/blktrace_api.h
@@ -9,7 +9,7 @@
 enum {
 	BLK_TC_READ	= 1 << 0,	/* reads */
 	BLK_TC_WRITE	= 1 << 1,	/* writes */
-	BLK_TC_BARRIER	= 1 << 2,	/* barrier */
+	BLK_TC_FLUSH	= 1 << 2,	/* flush */
 	BLK_TC_SYNC	= 1 << 3,	/* sync */
 	BLK_TC_QUEUE	= 1 << 4,	/* queueing/merging */
 	BLK_TC_REQUEUE	= 1 << 5,	/* requeueing */
@@ -22,8 +22,9 @@ enum {
 	BLK_TC_META	= 1 << 12,	/* metadata */
 	BLK_TC_DISCARD	= 1 << 13,	/* discard requests */
 	BLK_TC_DRV_DATA	= 1 << 14,	/* binary driver data */
+	BLK_TC_FUA	= 1 << 15,	/* fua requests */
 
-	BLK_TC_END	= 1 << 15,	/* only 16-bits, reminder */
+	BLK_TC_END	= 1 << 15,	/* we've run out of bits! */
 };
 
 #define BLK_TC_SHIFT		(16)
